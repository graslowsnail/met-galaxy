/**
 * ChunkManager - Orchestrates chunk lifecycle and data management
 * 
 * This component handles the high-level coordination between data fetching,
 * chunk creation, and rendering. It connects the hooks with the rendering
 * components and manages the overall chunk lifecycle.
 */

import React, { memo, useCallback, useEffect, useRef } from 'react'
import { useChunkData } from './hooks/useChunkData'
import { useVirtualization } from './hooks/useVirtualization'
import GridRenderer from './GridRenderer'
import type { 
  Chunk, 
  ChunkCoordinates, 
  ImageItem, 
  Position,
  ViewportState
} from './types/grid'
import {
  generateImageId,
  generateAspectRatio,
  calculateImageDimensions,
  calculateBoundingBox,
  calculateOptimalChunkLayout,
} from './utils/chunkCalculations'
import { 
  COLUMN_WIDTH,
  CHUNK_SIZE,
  CHUNK_HEIGHT,
  DEBUG_LOGGING
} from './utils/constants'
import type { Artwork } from '@/types/api'

interface ChunkManagerProps {
  /** Current viewport state from useViewport hook */
  viewport: ViewportState
  /** Whether dragging is currently active */
  isDragging: boolean
  /** Whether viewport is initialized */
  isInitialized: boolean
  /** Callback when an image is clicked */
  onImageClick?: (image: ImageItem, event: React.MouseEvent) => void
  /** Whether to show performance overlay */
  showPerformanceOverlay?: boolean
  /** Movement prediction for intelligent prefetching */
  movementPrediction?: {
    direction: Position
    speed: number
    predictedChunks: Array<{ x: number; y: number; priority: number }>
  }
}

/**
 * Generate image items from artwork data
 */
function generateChunkImagesFromArtworks(chunkX: number, chunkY: number, artworks: Artwork[]): ImageItem[] {
  // Filter artworks that have valid images
  const validArtworks = artworks
    .slice(0, CHUNK_SIZE)
    .filter((artwork) => Boolean(artwork.primaryImageSmall ?? artwork.primaryImage))
  
  // If we don't have enough valid artworks, duplicate some to fill the chunk
  const filledArtworks: Artwork[] = []
  for (let i = 0; i < CHUNK_SIZE; i++) {
    if (validArtworks.length > 0) {
      filledArtworks.push(validArtworks[i % validArtworks.length]!)
    } else {
      // If no valid artworks, we'll handle this below
      break
    }
  }
  
  return filledArtworks.map((artwork, i) => {
      const aspectRatio = generateAspectRatio(chunkX, chunkY, i)
      const { width, height } = calculateImageDimensions(aspectRatio)

      // Use primaryImageSmall if available, fallback to primaryImage
      const imageUrl = artwork.primaryImageSmall ?? artwork.primaryImage
      const src = imageUrl!

      return {
        id: generateImageId('artwork', chunkX, chunkY, i, artwork.id),
        src,
        width,
        height,
        aspectRatio,
        chunkX,
        chunkY,
        localIndex: i,
        // Database fields - store both database ID and Met objectId
        databaseId: artwork.id, // Add explicit database ID field
        objectId: artwork.objectId ?? 0,
        title: artwork.title,
        artist: artwork.artist,
        date: artwork.date,
        department: artwork.department,
        culture: artwork.culture,
        medium: artwork.medium,
      }
    })
}

/**
 * Create a chunk as a discrete grid cell
 */
function createChunk(
  chunkX: number, 
  chunkY: number, 
  chunkDataMap: Map<string, import('./types/grid').ChunkData>,
  fetchResults?: Map<string, Artwork[]>
): Chunk {
  const chunkKey = `${chunkX},${chunkY}`
  const chunkData = chunkDataMap.get(chunkKey)
  
  // Get artwork data for this chunk
  let images: ImageItem[] = []
  let artworks: Artwork[] | undefined = undefined
  
  // Try to get artworks from state first, then fallback to fetch results
  if (chunkData?.artworks && chunkData.artworks.length > 0) {
    artworks = chunkData.artworks
  } else if (fetchResults?.has(chunkKey)) {
    artworks = fetchResults.get(chunkKey)
  }
  
  if (DEBUG_LOGGING) {
    console.log(`Creating chunk ${chunkX},${chunkY}:`, {
      hasChunkData: Boolean(chunkData?.artworks),
      artworkCount: chunkData?.artworks?.length ?? 0,
      hasFetchResults: Boolean(fetchResults?.has(chunkKey)),
      fetchResultsCount: fetchResults?.get(chunkKey)?.length ?? 0,
      finalArtworkCount: artworks?.length ?? 0,
      loading: chunkData?.loading ?? false,
      error: chunkData?.error
    })
  }
  
  if (artworks && artworks.length > 0) {
    if (DEBUG_LOGGING) {
      console.log(`Chunk ${chunkX},${chunkY} - using ${artworks.length} artworks`)
    }
    images = generateChunkImagesFromArtworks(chunkX, chunkY, artworks)
    if (DEBUG_LOGGING) {
      console.log(`Chunk ${chunkX},${chunkY} - generated ${images.length} images`)
    }
  }

  // Ensure React keys remain unique (IDs are already generated by utility functions)
  images = images.map((img) => ({
    ...img,
    chunkX,
    chunkY,
  }))

  // Use optimized layout calculation for better space utilization
  const positions = calculateOptimalChunkLayout(
    images.map(img => ({ width: img.width, height: img.height })),
    chunkX,
    chunkY
  )

  return {
    id: `chunk-${chunkX}-${chunkY}`,
    x: chunkX,
    y: chunkY,
    images,
    positions,
    bounds: calculateBoundingBox(positions, COLUMN_WIDTH),
    actualHeight: CHUNK_HEIGHT // Fixed grid cell height
  }
}

/**
 * Main chunk manager component
 */
const ChunkManager = memo(function ChunkManager({
  viewport,
  isDragging,
  isInitialized,
  onImageClick,
  showPerformanceOverlay = true,
  movementPrediction = { direction: { x: 0, y: 0 }, speed: 0, predictedChunks: [] }
}: ChunkManagerProps) {
  
  // Use data management hook with streaming capabilities
  const { chunkDataMap, fetchChunkData, fetchChunksWithPriority } = useChunkData()
  
  // Core chunk state
  const [chunks, setChunks] = React.useState<Map<string, Chunk>>(new Map())
  
  // Use virtualization hook
  const { 
    visibleChunks,
    chunksToLoad,
    updateVirtualization
  } = useVirtualization({
    viewport,
    isDragging,
    isInitialized,
    chunks,
    setChunks
  })

  // Movement prediction is passed as a prop for intelligent prefetching

  // Performance tracking
  const loadingChunks = useRef<Set<string>>(new Set())
  
  // ============================================================================
  // CHUNK LOADING LOGIC
  // ============================================================================
  
  /**
   * Load chunks using streaming approach - chunks render individually as data arrives
   */
  const loadChunks = useCallback(async (coords: ChunkCoordinates[]) => {
    if (DEBUG_LOGGING) {
      console.log(`üöÄ ChunkManager: Streaming load for ${coords.length} coordinates:`, coords.map(c => `(${c.x},${c.y})`).join(', '))
    }
    
    const chunksToCreate: ChunkCoordinates[] = []
    const visibleChunksToFetch: ChunkCoordinates[] = []
    const bufferChunksToFetch: ChunkCoordinates[] = []
    
    // Separate chunks by state and prioritize visible vs buffer chunks
    for (const coord of coords) {
      const chunkKey = `${coord.x},${coord.y}`
      const chunkData = chunkDataMap.get(chunkKey)
      const chunkExists = chunks.has(chunkKey)
      const chunkLoading = loadingChunks.current.has(chunkKey)
      
      if (!chunkExists && !chunkLoading) {
        // Mark as loading to show skeleton
        loadingChunks.current.add(chunkKey)
        
        if (!chunkData || (!chunkData.artworks && !chunkData.loading)) {
          // Need to fetch data first - prioritize based on whether it's visible
          const isVisible = visibleChunks.some(vc => vc.x === coord.x && vc.y === coord.y)
          if (isVisible) {
            visibleChunksToFetch.push(coord)
            if (DEBUG_LOGGING) {
              console.log(`üìã Chunk ${chunkKey} needs HIGH PRIORITY fetch (visible)`)
            }
          } else {
            bufferChunksToFetch.push(coord)
            if (DEBUG_LOGGING) {
              console.log(`üìã Chunk ${chunkKey} needs LOW PRIORITY fetch (buffer)`)
            }
          }
        } else if (chunkData.artworks) {
          // Data is ready, can create chunk immediately
          chunksToCreate.push(coord)
          if (DEBUG_LOGGING) {
            console.log(`üèóÔ∏è Chunk ${chunkKey} ready for immediate creation`)
          }
        }
      } else if (DEBUG_LOGGING) {
        console.log(`‚è≠Ô∏è Chunk ${chunkKey} skipped - exists: ${chunkExists}, loading: ${chunkLoading}`)
      }
    }
    
    // Start streaming fetch with priority (doesn't wait for completion)
    if (visibleChunksToFetch.length > 0 || bufferChunksToFetch.length > 0) {
      await fetchChunksWithPriority(visibleChunksToFetch, bufferChunksToFetch)
      if (DEBUG_LOGGING) {
        console.log(`üöÄ Started streaming fetch: ${visibleChunksToFetch.length} high priority, ${bufferChunksToFetch.length} low priority`)
      }
    }
    
    // Create chunks that already have data ready (immediate rendering)
    createChunksFromCoordinates(chunksToCreate)
    
  }, [chunks, chunkDataMap, fetchChunksWithPriority, visibleChunks])

  /**
   * Create chunks from coordinates that have data ready
   */
  const createChunksFromCoordinates = useCallback((coords: ChunkCoordinates[]) => {
    if (coords.length === 0) return
    
    const newChunks: Chunk[] = []
    
    for (const coord of coords) {
      const chunkKey = `${coord.x},${coord.y}`
      
      if (!chunks.has(chunkKey)) {
        try {
          const newChunk = createChunk(coord.x, coord.y, chunkDataMap)
          if (newChunk && newChunk.positions.length > 0) {
            newChunks.push(newChunk)
            if (DEBUG_LOGGING) {
              console.log(`‚úÖ Chunk ${chunkKey} created from available data`)
            }
          } else {
            if (DEBUG_LOGGING) {
              console.log(`‚ö†Ô∏è Chunk ${chunkKey} created but empty - removing from loading state`)
            }
            loadingChunks.current.delete(chunkKey)
          }
        } catch (error) {
          console.error(`‚ùå Error creating chunk ${coord.x},${coord.y}:`, error)
        }
      }
    }
    
    // Add new chunks to state immediately
    if (newChunks.length > 0) {
      setChunks(prev => {
        const updated = new Map(prev)
        newChunks.forEach(chunk => {
          const chunkKey = `${chunk.x},${chunk.y}`
          updated.set(chunkKey, chunk)
          loadingChunks.current.delete(chunkKey)
        })
        return updated
      })
    }
  }, [chunks, chunkDataMap])
  
  // Store loadChunks in a ref to avoid dependency issues
  const loadChunksRef = useRef(loadChunks)
  loadChunksRef.current = loadChunks

  // ============================================================================
  // EFFECTS
  // ============================================================================
  
  /**
   * Load chunks when chunksToLoad changes
   */
  useEffect(() => {
    if (chunksToLoad.length > 0) {
      void loadChunksRef.current(chunksToLoad)
    }
  }, [chunksToLoad])

  /**
   * STREAMING: Create chunks immediately when their data becomes available
   * This is the key to streaming performance - chunks render as soon as data arrives
   */
  useEffect(() => {
    const chunksReadyForCreation: ChunkCoordinates[] = []
    
    // Check all loading chunks to see if their data has arrived
    for (const chunkKey of loadingChunks.current) {
      const [xStr, yStr] = chunkKey.split(',')
      const x = parseInt(xStr!, 10)
      const y = parseInt(yStr!, 10)
      
      const chunkData = chunkDataMap.get(chunkKey)
      const chunkExists = chunks.has(chunkKey)
      
      // If data is ready and chunk doesn't exist yet, create it immediately
      if (chunkData?.artworks && !chunkExists && !chunkData.loading) {
        chunksReadyForCreation.push({ x, y })
        if (DEBUG_LOGGING) {
          console.log(`üéØ STREAMING: Chunk ${chunkKey} data arrived, creating immediately`)
        }
      }
    }
    
    // Create chunks that just got their data
    if (chunksReadyForCreation.length > 0) {
      createChunksFromCoordinates(chunksReadyForCreation)
    }
  }, [chunkDataMap, chunks, createChunksFromCoordinates])

  /**
   * INTELLIGENT PREFETCHING: Load predicted chunks based on movement direction
   * This anticipates user movement for seamless navigation
   */
  useEffect(() => {
    // Only prefetch if user is moving significantly and not dragging
    if (isDragging || !isInitialized || movementPrediction.predictedChunks.length === 0) {
      return
    }
    
    // Filter predicted chunks to only those that aren't already loaded/loading
    const chunksToPreload: ChunkCoordinates[] = []
    
    for (const prediction of movementPrediction.predictedChunks) {
      const chunkKey = `${prediction.x},${prediction.y}`
      const chunkData = chunkDataMap.get(chunkKey)
      const chunkExists = chunks.has(chunkKey)
      const chunkLoading = loadingChunks.current.has(chunkKey)
      
      // Skip if already exists, loading, or already in current chunksToLoad
      const alreadyInBuffer = chunksToLoad.some(coord => coord.x === prediction.x && coord.y === prediction.y)
      
      if (!chunkExists && !chunkLoading && !chunkData && !alreadyInBuffer) {
        chunksToPreload.push({ x: prediction.x, y: prediction.y })
        if (DEBUG_LOGGING) {
          console.log(`üîÆ PREFETCH: Queuing predicted chunk ${chunkKey} (priority: ${prediction.priority.toFixed(2)})`)
        }
      }
    }
    
    // Start prefetching with low priority (doesn't wait)
    if (chunksToPreload.length > 0) {
      void fetchChunksWithPriority([], chunksToPreload) // Empty array for visible, predicted chunks as buffer
      if (DEBUG_LOGGING) {
        console.log(`üöÄ PREFETCH: Started loading ${chunksToPreload.length} predicted chunks`)
      }
    }
  }, [movementPrediction, isDragging, isInitialized, chunks, chunkDataMap, loadingChunks, chunksToLoad, fetchChunksWithPriority])

  /**
   * Store updateVirtualization in ref to avoid dependency cycles
   */
  const updateVirtualizationRef = useRef(updateVirtualization)
  updateVirtualizationRef.current = updateVirtualization

  /**
   * Initial virtualization trigger when initialized
   */
  useEffect(() => {
    if (isInitialized && !isDragging) {
      if (DEBUG_LOGGING) {
        console.log('üöÄ ChunkManager: Initial virtualization trigger')
      }
      updateVirtualizationRef.current()
    }
  }, [isInitialized, isDragging])

  /**
   * Handle window resize and clear chunks
   */
  useEffect(() => {
    const handleResize = () => {
      // Clear layout state on resize but DON'T reset translate position
      setChunks(new Map())
      loadingChunks.current.clear()
    }
    
    window.addEventListener("resize", handleResize)
    return () => window.removeEventListener("resize", handleResize)
  }, [])

  // ============================================================================
  // RENDER
  // ============================================================================
  
  // Calculate current translation position for rendering
  const translate: Position = {
    x: viewport.translateX,
    y: viewport.translateY
  }



  if (DEBUG_LOGGING) {
    console.log(`üéõÔ∏è ChunkManager: Rendering ${chunks.size} chunks, ${visibleChunks.length} visible, ${chunksToLoad.length} to load`)
  }

  return (
    <GridRenderer
      chunks={chunks}
      translate={translate}
      isDragging={isDragging}
      onImageClick={onImageClick}
      loadingChunks={loadingChunks.current}
      chunksToLoad={chunksToLoad}
      visibleChunks={visibleChunks.length}
      chunkDataMap={chunkDataMap}
      showPerformanceOverlay={showPerformanceOverlay}
    />
  )
})

// Add display name for better debugging
ChunkManager.displayName = 'ChunkManager'

export default ChunkManager
